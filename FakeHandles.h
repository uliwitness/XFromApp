/*	===========================================================================	PROJECT:	FakeHandles		FILE:		FakeHandles.h		PURPOSE:	Simulate Handles on machines which only have ANSI-C to easily				port some of the more simple Macintosh code fragments to other				platforms.			COPYRIGHT:	(C) Copyright 1998 by M. Uli Kusterer, all rights reserved.					REACH ME AT:				E-MAIL:		witness@weblayout.com				URL:		http://www.weblayout.com/witness		DIRECTIONS:		A Handle is a memory block that remembers its size automatically.		To the user, a Handle is simply a pointer to a pointer to the actual		data. Dereference it twice to get at the actual data. Before you		pass a once-dereferenced Handle to any other functions, you need to		call HLock() on it to avoid that it moves. Call HUnlock() when you		are finished with that.		To create a Handle, use NewHandle(). To free a Handle, call		DisposeHandle(). To resize use SetHandleSize() (the Handle itself		will not change, but the pointer to the actual data may change),		GetHandleSize() returns the actual size of the Handle.		Before making any of these calls, you *must have* called		InitHandles().		REVISIONS:		2001-02-15	UK		Added InitHandles, HLock and HUnlock macros and							header file.		1998-08-30	UK		Created.					======================================================================== */#ifndef FAKEHANDLES_H#define FAKEHANDLES_H#pragma mark [Headers]#define MAC_OS		1/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Headers:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */#include	<stdlib.h>#include	<stdio.h>#if MAC_OS && defined(__MWERKS__)	#include	<Memory.h>#else	#include	<Carbon/Carbon.h>#endif/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Constants:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */#ifndef NULL  #define NULL	0L#endif#define MAX_HANDLE_COUNT		1024	// Max. number of Handles that may be created.#ifndef MAC_OS// Error codes MemError() may return after Handle calls:enum{	noErr		= 0,	// No error, success.	memFulErr	= -108	// Out of memory error.};/* For non-MacOS platforms, we map the MacOS Memory Manager routines that deal	with Handles to our Fake Handle routines. In that case, Handles can not	move, and thus HLock and HUnlock map to no-ops. */#define InitHandles()		InitFakeHandles( gMasterPointers )#define NewHandle			NewFakeHandle#define DisposeHandle		DisposeFakeHandle#define SetHandleSize		SetFakeHandleSize#define	GetHandleSize		GetFakeHandleSize#define HLock(handle)		#define HUnlock(handle)		#define MemError()			gFakeHandleError#else/* If we're running on MacOS we use the built-in Handle support.	In that case, the call to init the memory manager is not needed	and maps to a no-op. */#define InitHandles()		#endif/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Data Types:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */#ifndef MAC_OS// Data types special to Mac:typedef	char**			Handle;typedef unsigned char	Boolean;#endif// Private data structure used internally to keep track of Handles:typedef struct MasterPointer{	char*		actualPointer;	// The actual Pointer we're pointing to.	Boolean		used;			// Is this master Ptr being used?	long		memoryFlags;	// Some flags for this Handle.	long		size;			// The size of this Handle.} MasterPointer;/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Globals:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */extern MasterPointer	gMasterPointers[MAX_HANDLE_COUNT];extern long				gFakeHandleError;/* ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ	Prototypes:   ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ */void	InitFakeHandles( MasterPointer* masterPtrArray );Handle	NewFakeHandle( long theSize );void	DisposeFakeHandle( Handle theHand );long	GetFakeHandleSize( Handle theHand );void	SetFakeHandleSize( Handle theHand, long theSize );#endif /*FAKEHANDLES_H*/