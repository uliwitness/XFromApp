/*	***************************************************************************	PROJECT:	C++ XFromApp		FILE:		MacExternalCall.cpp		PURPOSE:	Load an external on Mac.			COPYRIGHT:	(C) Copyright 2001 by M. Uli Kusterer, all rights reserved.					REACH ME AT:				E-MAIL:		witness@zathras.de				URL:		http://www.zathras.de			REVISIONS:		2001-02-15	UK		Created.					************************************************************************ */#pragma mark [Headers]/* --------------------------------------------------------------------------------	Headers:   ----------------------------------------------------------------------------- */#include	<cstring>#include	<cstdio>#include	<stdexcept>#include	"MacExternalCall.h"#if __MWERKS__#include	<Resources.h>#include	<ConditionalMacros.h>#include	<CodeFragments.h>#else#include	<Carbon/Carbon.h>#endif#include	"MachOCFMGlue.h"#include	"XFromAppUPPs.h"#pragma mark -/* --------------------------------------------------------------------------------	GetMacintoshExternal:		Return the ProcPtr to an external fetched from a Macintosh-style code		resource.		TAKES:		isFcn	-	TRUE to fetch an external function, FALSE to fetch an external					command. On Mac this is distinguished using the resource types					XCMD vs XFCN.		theName	-	C String containing the name of the external to load.		GIVES:		XCMDProcUPP	-	Pointer to the main entry point of the external.						NULL if there is no external of that name.   ----------------------------------------------------------------------------- */XCMDProcUPP	GetMacintoshExternal( bool isFcn, const char* theName ){	Handle					myHandle;	OSErr					myErr = noErr;	CFragConnectionID		myConnID;	Ptr						myMainAddr;	Str255					myErrName;	Str255					myXNamePStr;	ResType					theType;		// First try fully native Xes:  #if TARGET_API_MAC_CARBON	theType = isFcn ? 'Xfcn' : 'Xcmd';  #elif TARGET_RT_MAC_CFM	theType = isFcn ? 'xfcn' : 'xcmd';  #else	theType = isFcn ? 'XFCN' : 'XCMD';  #endif		// Convert X name from C String to Pascal String:	myXNamePStr[0] = std::strlen( theName );	std::memmove( myXNamePStr +1, theName, myXNamePStr[0] );		// Get the resource as a Handle and load it:	myHandle = GetNamedResource( theType, myXNamePStr );	if( myHandle == NULL )	// No such res?	{	  #if TARGET_API_MAC_CARBON		// Just fall through to the error, we can't run InterfaceLib Xes.	  #elif TARGET_RT_MAC_CFM		theType = isFcn ? 'XFCN' : 'XCMD';	// Try possibly native Xes.		myHandle = GetNamedResource( theType, myXNamePStr );	  #endif				if( myHandle == NULL || ResError() != noErr )			return NULL;	}	DetachResource( myHandle );	// Don't ask me why, but without this it crashes abysmally...	HLock(myHandle);	  #if TARGET_API_MAC_CARBON	/* For Carbon, an Xcmd or Xfcn is a CFM Fragment in a resource, so		we use GetMemFragment to prepare the code. */	myErr = GetMemFragment( *myHandle, GetHandleSize(myHandle), 							myXNamePStr, kPrivateCFragCopy, &myConnID, 							(Ptr*)&myMainAddr, myErrName);	if( myErr )	// Build an error message with lots of info for the user:	{		char	errStr[1024] = "Couldn't load the external \"";		char	tempStr[256];				std::strncat( errStr, theName, 1024 );		std::strncat( errStr, "\" because of an error ID ", 1024 );		snprintf( tempStr, 256, "%d", myErr );		std::strncat( errStr, tempStr, 1024 );		std::strncat( errStr, " loading fragment \"", 1024 );		// Convert frament name from Pascal String to C String:		tempStr[myErrName[0]] = 0;		std::memmove( tempStr, myErrName +1, myErrName[0] );		std::strncat( errStr, tempStr, 1024 );		std::strncat( errStr, "\".", 1024 );				throw std::runtime_error( errStr );	}		#if TARGET_RT_MAC_MACHO	myMainAddr = (Ptr) NewXCMDProc( (void*) myMainAddr );	#endif  #else	switch( theType )	{		case 'xcmd':		case 'xfcn':			myMainAddr = *myHandle;			break;				case 'XCMD':		case 'XFCN':			myMainAddr = (Ptr) NewXCMDProc(*myHandle);			break;				default:			myMainAddr = NULL;			break;	}  #endif		return( (XCMDProcUPP) myMainAddr );}